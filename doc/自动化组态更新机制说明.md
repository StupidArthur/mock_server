# 自动化组态更新机制说明

## 概述

本系统实现了自动化的组态更新机制：**config模块通过Redis发送配置更新消息，PLC在运行过程中自动检测并在周期间隙应用更新**。

## 核心特性

1. **自动化**：无需手动调用，PLC在运行过程中自动检测并应用更新
2. **线程安全**：使用锁机制确保配置更新在周期间隙执行，不会打断运行循环
3. **差异化更新**：只更新变化的部分，而不是替换整个配置
4. **完整支持**：支持实例增删改、连接关系更新、执行顺序更新、cycle_time更新

---

## 数据流向

### 完整流程（以新增PID实例为例）

```
配置文件 (config/example_config.yaml)
    ↓
config_manager.update_config_to_plc(use_redis=True)
    ↓
[步骤1: 分析差异]
    ↓
diff = analyze_config_diff(new_config, plc_running_config)
    ↓ diff['added_algorithms'] = {'pid2': {...}}
[步骤2: 构造更新消息]
    ↓
update_message = {
    'type': 'config_update_diff',
    'diff': diff,
    'full_config': new_config,
    'rebuild_instances': True,
    'cycle_time_changed': False
}
    ↓
[步骤3: 发送到Redis]
    ↓
redis_client.publish("plc:config:update", json.dumps(update_message))
    ↓
[步骤4: Runner接收消息]
    ↓
Runner._command_subscriber_loop() 接收消息
    ↓
设置 _config_update_pending = True
    ↓
[步骤5: 在周期间隙应用更新]
    ↓
Runner._run_loop() 检测到更新标志
    ↓
_apply_pending_config_update()
    ↓
_apply_config_update_diff(update_data)
    ↓
[步骤6: 应用差异到plc_configuration]
    ↓
plc_configuration.online_add_algorithm('pid2', 'PID', params)
    ↓
plc_configuration.config['algorithms']['pid2'] = {...}  ← 内存配置已更新
    ↓
[步骤7: 更新Runner实例]
    ↓
runner.update_configuration(rebuild_instances=True)
    ↓
runner._initialize_algorithms()
    ↓
runner.algorithms['pid2'] = PID(...)  ← 运行实例已创建
runner.params['pid2.pv'] = 0.0        ← 参数字典已更新
runner.execution_order = [...]        ← 执行顺序已更新
    ↓
[步骤8: 保存到文件]
    ↓
plc_configuration.save_to_local()
    ↓
plc/local/config.yaml  ← 文件已更新
```

---

## 代码实现

### 1. config模块发送更新消息

```python
# config/configuration.py
def update_config_to_plc(self, plc_configuration=None, config=None, 
                        rebuild_instances=False, use_redis=True):
    """
    更新组态到PLC（通过Redis消息通知）
    """
    # 分析差异
    diff = self.analyze_config_diff(config, plc_config)
    
    # 构造更新消息
    update_message = {
        'type': 'config_update_diff',
        'diff': diff,
        'full_config': config,
        'rebuild_instances': rebuild_instances,
        'cycle_time_changed': diff['cycle_time_changed'],
        'cycle_time': config.get('cycle_time') if diff['cycle_time_changed'] else None
    }
    
    # 发送到Redis
    redis_client.publish("plc:config:update", json.dumps(update_message))
```

### 2. Runner接收消息并设置标志

```python
# plc/runner.py
def _command_subscriber_loop(self):
    """命令订阅循环（监听Redis消息）"""
    while self._running:
        message = pubsub.get_message(timeout=0.1)
        if message and message['type'] == 'message':
            if channel == "plc:config:update":
                config_data = json.loads(message['data'])
                config_type = config_data.get('type', 'config_update')
                
                if config_type == 'config_update_diff':
                    # 设置更新标志，在周期间隙执行
                    self._config_update_pending = True
                    self._pending_config_update = config_data
                    logger.info("Configuration update pending, will be applied at next cycle gap")
```

### 3. 在周期间隙应用更新

```python
# plc/runner.py
def _run_loop(self):
    """运行循环（在独立线程中执行）"""
    self.clock.start()
    
    while self._running:
        # 1. 步进模拟时钟
        self.clock.step()
        
        # 2. 执行周期计算逻辑
        self.execute_one_cycle()
        
        # 3. 在周期间隙检查并应用配置更新
        if self._config_update_pending and self._pending_config_update:
            try:
                logger.info("Applying pending configuration update at cycle gap")
                self._apply_pending_config_update()
                self._config_update_pending = False
                self._pending_config_update = None
                logger.info("Configuration update applied successfully")
            except Exception as e:
                logger.error(f"Failed to apply configuration update: {e}", exc_info=True)
                self._config_update_pending = False
                self._pending_config_update = None
        
        # 4. 等待到下一个周期
        self.clock.sleep_to_next_cycle()
```

### 4. 应用差异化更新

```python
# plc/runner.py
def _apply_config_update_diff(self, update_data: dict):
    """应用差异化的配置更新"""
    diff = update_data.get('diff', {})
    rebuild_instances = update_data.get('rebuild_instances', False)
    
    with self._lock:
        # 1. 应用差异到plc_configuration（使用在线配置API）
        # 删除已移除的算法
        for name in diff.get('removed_algorithms', []):
            self.config.online_remove_algorithm(name)
        
        # 添加新算法
        for name, algo_config in diff.get('added_algorithms', {}).items():
            algo_type = algo_config.get('type', 'unknown')
            params = algo_config.get('params', {})
            self.config.online_add_algorithm(name, algo_type, params)
        
        # 更新修改的算法
        for name, change in diff.get('modified_algorithms', {}).items():
            params = change.get('to', {}).get('params', {})
            self.config.online_update_algorithm(name, params)
        
        # 更新连接关系
        # ...
        
        # 2. 保存到本地config.yaml
        self.config.save_to_local(self.local_dir)
        
        # 3. 更新Runner实例（重建或更新参数）
        self.update_configuration(rebuild_instances=rebuild_instances)
        
        # 4. 更新执行顺序
        self.execution_order = self.config.get_execution_order()
        
        # 5. 更新cycle_time（如果变化）
        if cycle_time_changed and new_cycle_time is not None:
            self.clock.cycle_time = new_cycle_time
```

---

## 使用示例

### 基本使用

```python
from config.configuration import ConfigurationManager
import redis

# 1. 初始化config_manager（需要提供Redis配置）
redis_config = {
    'host': 'localhost',
    'port': 6379,
    'db': 0
}
config_manager = ConfigurationManager(redis_config=redis_config)

# 2. 加载包含新PID实例的配置文件
file_config = config_manager.load_config_file("config/new_config.yaml")
# new_config.yaml 包含 pid2 实例

# 3. 更新到PLC（自动通过Redis发送消息）
success = config_manager.update_config_to_plc(config=file_config, use_redis=True)
# ↓ PLC在运行过程中自动接收并应用更新
```

### 完整流程示例

```python
# 1. 初始化
config_manager = ConfigurationManager(redis_config=redis_config)
plc_config = Configuration(local_dir="plc/local")
runner = Runner(configuration=plc_config, redis_config=redis_config, ...)

# 2. 启动PLC
runner.start()

# 3. 在运行时更新配置
file_config = config_manager.load_config_file("config/new_config.yaml")
config_manager.update_config_to_plc(config=file_config, use_redis=True)

# ↓ PLC自动接收消息并在周期间隙应用更新
# ↓ 无需手动调用 runner.update_configuration()
```

---

## 消息格式

### config_update_diff 消息

```json
{
    "type": "config_update_diff",
    "diff": {
        "added_models": {
            "tank2": {
                "type": "cylindrical_tank",
                "params": {...}
            }
        },
        "removed_models": [],
        "added_algorithms": {
            "pid2": {
                "type": "PID",
                "params": {"kp": 12.0, "ti": 30.0, ...}
            }
        },
        "removed_algorithms": [],
        "modified_models": {},
        "modified_algorithms": {},
        "added_connections": [
            {"from": "pid2.mv", "to": "valve2.target_opening"}
        ],
        "removed_connections": [],
        "cycle_time_changed": false
    },
    "full_config": {
        "cycle_time": 1.0,
        "models": {...},
        "algorithms": {...},
        "connections": [...]
    },
    "rebuild_instances": true,
    "cycle_time_changed": false,
    "cycle_time": null
}
```

---

## 关键点

### 1. 线程安全

- 配置更新在 `_run_loop()` 的周期间隙执行
- 使用 `self._lock` 确保更新过程不会被其他操作打断
- 更新标志 `_config_update_pending` 确保更新只执行一次

### 2. 差异化更新

- 只更新变化的部分，而不是替换整个配置
- 使用 `plc_configuration` 的在线配置API（`online_add_algorithm`等）
- 减少不必要的实例重建

### 3. 执行顺序更新

- 配置更新后，自动重新计算执行顺序
- 如果连接关系变化，执行顺序会自动调整

### 4. cycle_time更新

- 如果cycle_time变化，会自动更新 `self.clock.cycle_time`
- 新的cycle_time在下一个周期生效

---

## 注意事项

1. **Redis连接**：config_manager需要配置Redis才能发送更新消息
2. **PLC运行状态**：PLC必须在运行状态才能接收并应用更新
3. **状态丢失**：重建实例会丢失算法状态（如PID的积分项）
4. **文件同步**：配置更新后会自动保存到 `plc/local/config.yaml`

---

## 兼容性

- **旧方式兼容**：`update_config_to_plc(use_redis=False)` 仍然支持直接调用API（但不推荐）
- **消息格式兼容**：支持 `config_update` 和 `config_reset` 消息类型（完整配置更新）

