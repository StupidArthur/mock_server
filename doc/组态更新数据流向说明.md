# 组态更新数据流向说明（以新增PID实例为例）

> **更新说明**：本文档已更新，描述了新的自动化组态更新机制。PLC在运行过程中通过Redis消息自动接收并应用配置更新，无需手动步骤。

## 完整数据流向图（新机制）

```
配置文件 (config/example_config.yaml)
    ↓
config_manager.load_config_file()
    ↓
config_manager.update_config_to_plc(plc_config)
    ↓
[步骤1: 分析差异]
    ↓
diff['added_algorithms'] = {'pid2': {...}}
    ↓
[步骤2: 调用PLC组态API]
    ↓
plc_configuration.online_add_algorithm('pid2', 'PID', params)
    ↓
plc_configuration.config['algorithms']['pid2'] = {...}  # 更新内存
    ↓
[步骤3: 通知Runner重建实例]
    ↓
runner.update_configuration(rebuild_instances=True)
    ↓
runner._initialize_algorithms()  # 重新创建所有算法实例
    ↓
self.algorithms['pid2'] = PID(...)  # 创建新的PID实例
    ↓
[步骤4: 更新参数字典]
    ↓
runner._update_params_from_algorithms()
    ↓
self.params['pid2.pv'] = 0.0
self.params['pid2.sv'] = 1.0
self.params['pid2.mv'] = 0.0
    ↓
[步骤5: 更新执行顺序]
    ↓
runner.execution_order = ['pid1', 'pid2', 'valve1', ...]
    ↓
[步骤6: 保存到文件（可选）]
    ↓
config_manager.save_config_to_local()
    ↓
plc/local/config.yaml (文件更新)
```

---

## 详细步骤说明

### 步骤1: 分析差异

```python
# config/configuration.py
def update_config_to_plc(self, plc_configuration, config):
    # 获取当前PLC运行配置
    plc_config = self.get_plc_running_config(plc_configuration)
    
    # 分析差异
    diff = self.analyze_config_diff(config, plc_config)
    
    # 结果示例：
    # diff['added_algorithms'] = {
    #     'pid2': {
    #         'type': 'PID',
    #         'params': {'kp': 12.0, 'ti': 30.0, 'sv': 1.0, ...}
    #     }
    # }
```

---

### 步骤2: 调用PLC组态API（更新内存中的配置）

```python
# config/configuration.py
for name, algo_config in diff['added_algorithms'].items():
    algo_type = algo_config.get('type', 'unknown')
    params = algo_config.get('params', {})
    
    # 调用PLC组态API
    plc_configuration.online_add_algorithm(name, algo_type, params)
```

**内部实现**：
```python
# plc/plc_configuration.py
def online_add_algorithm(self, name: str, algo_type: str, params: dict):
    with self._lock:  # 线程安全
        if 'algorithms' not in self.config:
            self.config['algorithms'] = {}
        
        # 更新内存中的配置字典
        self.config['algorithms'][name] = {
            'type': algo_type,
            'params': params.copy()
        }
        # ↓ 此时 plc_configuration.config['algorithms']['pid2'] 已存在
```

**数据状态**：
- ✅ `plc_configuration.config` (内存) 已更新
- ❌ `plc/local/config.yaml` (文件) 还未更新
- ❌ `Runner.algorithms` (运行实例) 还未创建

---

### 步骤3: 通知Runner重建实例

```python
# config/configuration.py
if rebuild_instances:
    logger.warning("Instances need to be rebuilt. "
                   "Please call Runner.update_configuration(rebuild_instances=True)")
```

**需要手动调用**（因为config_manager不知道Runner实例）：
```python
# 在run_plc.py或main.py中
runner.update_configuration(rebuild_instances=True)
```

**内部实现**：
```python
# plc/runner.py
def update_configuration(self, rebuild_instances: bool = False):
    with self._lock:
        if rebuild_instances:
            # 重新创建所有实例
            self._initialize_models()      # 重新创建模型实例
            self._initialize_algorithms()   # 重新创建算法实例
```

**创建新实例**：
```python
# plc/runner.py
def _initialize_algorithms(self):
    algorithms_config = self.config.get_algorithms()
    
    for name, algo_config in algorithms_config.items():
        algo_type = algo_config.get('type')
        params = algo_config.get('params', {})
        
        if algo_type == 'PID':
            # 创建PID实例
            pid = PID(**params)
            self.algorithms[name] = pid  # ← 新实例创建
            # 例如：self.algorithms['pid2'] = PID(kp=12.0, ti=30.0, ...)
```

**数据状态**：
- ✅ `plc_configuration.config` (内存) 已更新
- ✅ `Runner.algorithms['pid2']` (运行实例) 已创建
- ❌ `plc/local/config.yaml` (文件) 还未更新

---

### 步骤4: 更新参数字典

```python
# plc/runner.py
def update_configuration(self, rebuild_instances: bool = False):
    if rebuild_instances:
        # ...
        # 重新初始化参数值
        self.params.clear()
        self._update_params_from_models()
        self._update_params_from_algorithms()  # ← 更新参数字典
```

**内部实现**：
```python
# plc/runner.py
def _update_params_from_algorithms(self):
    for name, algorithm in self.algorithms.items():
        # 从算法实例获取参数值
        for param_name, param_value in algorithm.input.items():
            self.params[f"{name}.{param_name}"] = param_value
        for param_name, param_value in algorithm.output.items():
            self.params[f"{name}.{param_name}"] = param_value
        
        # 例如：
        # self.params['pid2.pv'] = 0.0
        # self.params['pid2.sv'] = 1.0
        # self.params['pid2.mv'] = 0.0
```

**数据状态**：
- ✅ `plc_configuration.config` (内存) 已更新
- ✅ `Runner.algorithms['pid2']` (运行实例) 已创建
- ✅ `Runner.params` (参数字典) 已更新
- ❌ `plc/local/config.yaml` (文件) 还未更新

---

### 步骤5: 更新执行顺序

```python
# plc/runner.py
def update_configuration(self, rebuild_instances: bool = False):
    # 重新获取执行顺序（如果连接关系变化了）
    new_execution_order = self.config.get_execution_order()
    if new_execution_order != self.execution_order:
        self.execution_order = new_execution_order
        # 例如：['pid1', 'pid2', 'valve1', 'tank1', ...]
```

---

### 步骤6: 保存到文件（可选）

```python
# config/configuration.py
def save_config_to_local(self, config: Dict[str, Any] = None):
    # 保存到plc/local/config.yaml
    with open(self.local_config_file, 'w', encoding='utf-8') as f:
        yaml.dump(config, f, allow_unicode=True, default_flow_style=False)
```

**数据状态**：
- ✅ `plc_configuration.config` (内存) 已更新
- ✅ `Runner.algorithms['pid2']` (运行实例) 已创建
- ✅ `Runner.params` (参数字典) 已更新
- ✅ `plc/local/config.yaml` (文件) 已更新

---

## 完整代码示例

```python
from config.configuration import ConfigurationManager
from plc.plc_configuration import Configuration
from plc.runner import Runner

# 1. 初始化
config_manager = ConfigurationManager()
plc_config = Configuration(local_dir="plc/local")
runner = Runner(configuration=plc_config, ...)

# 2. 加载包含新PID实例的配置文件
file_config = config_manager.load_config_file("config/new_config.yaml")
# new_config.yaml 包含 pid2 实例

# 3. 更新到PLC组态（更新内存中的配置）
success = config_manager.update_config_to_plc(plc_config, config=file_config)
# ↓ 内部调用：
#    plc_config.online_add_algorithm('pid2', 'PID', {...})
# ↓ 结果：
#    plc_config.config['algorithms']['pid2'] = {...}  # 内存已更新

# 4. 通知Runner重建实例（创建运行实例）
runner.update_configuration(rebuild_instances=True)
# ↓ 内部调用：
#    runner._initialize_algorithms()
# ↓ 结果：
#    runner.algorithms['pid2'] = PID(...)  # 实例已创建
#    runner.params['pid2.pv'] = 0.0        # 参数字典已更新
#    runner.execution_order = [...]        # 执行顺序已更新

# 5. 保存到文件（持久化）
config_manager.save_config_to_local(file_config)
# ↓ 结果：
#    plc/local/config.yaml 文件已更新
```

---

## 数据流向总结

### 新增PID实例的数据流向

```
配置文件
    ↓
[1] config_manager.update_config_to_plc()
    ↓
[2] plc_configuration.online_add_algorithm()
    ↓ 更新内存配置
plc_configuration.config['algorithms']['pid2'] = {...}
    ↓
[3] runner.update_configuration(rebuild_instances=True)
    ↓ 创建运行实例
runner.algorithms['pid2'] = PID(...)
runner.params['pid2.*'] = {...}
    ↓
[4] config_manager.save_config_to_local()
    ↓ 保存到文件
plc/local/config.yaml
```

### 关键点

1. **内存配置更新**：`plc_configuration.config` 先更新（步骤2）
2. **运行实例创建**：`Runner.algorithms` 后创建（步骤3）
3. **文件持久化**：最后保存到文件（步骤4）

### 注意事项

1. **必须重建实例**：新增/删除实例时，必须调用 `runner.update_configuration(rebuild_instances=True)`
2. **状态丢失**：重建实例会丢失算法状态（如PID的积分项）
3. **文件同步**：内存配置更新后，需要手动保存到文件才能持久化

---

## 与其他模块的联动

### Communication模块

```python
# Communication模块需要更新OPCUA节点
communication.update_configuration(rebuild_instances=True)
# ↓ 如果rebuild_instances=True，需要重启OPCUA Server
```

### DataStorage模块

```python
# DataStorage模块需要更新配置
data_storage.update_configuration()
# ↓ 更新数据库表结构（如果需要）
```

---

## 完整更新流程（推荐）

```python
def update_config_complete(config_manager, plc_config, runner, 
                          communication, data_storage, config_file):
    """
    完整的配置更新流程
    """
    # 1. 加载配置文件
    config = config_manager.load_config_file(config_file)
    
    # 2. 分析差异
    plc_running_config = config_manager.get_plc_running_config(plc_config)
    diff = config_manager.analyze_config_diff(config, plc_running_config)
    
    # 3. 检查是否需要重建实例
    need_rebuild = (
        diff['added_models'] or diff['removed_models'] or
        diff['added_algorithms'] or diff['removed_algorithms']
    )
    
    # 4. 更新PLC组态（内存）
    success = config_manager.update_config_to_plc(plc_config, config)
    if not success:
        return False
    
    # 5. 更新Runner（运行实例）
    if need_rebuild:
        runner.update_configuration(rebuild_instances=True)
    else:
        runner.update_configuration(rebuild_instances=False)
    
    # 6. 更新Communication（OPCUA节点）
    communication.update_configuration(rebuild_instances=need_rebuild)
    
    # 7. 更新DataStorage
    data_storage.update_configuration()
    
    # 8. 保存到文件
    config_manager.save_config_to_local(config)
    
    return True
```

